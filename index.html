<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Executive Presentation</title>

    
    
    <link rel="stylesheet" href="vendor/pico.min.css"/>

    
    <style>
        
        :root {
            
            --primary: #2563eb;
            --secondary: #6b7280;
            --background: #ffffff;
            --surface: #f8f9fa;
            --text: #1a1a1a;
            --text-secondary: #6c757d;

            --prgb: 37, 99, 235;
            --srgb: 107, 114, 128;
            --trgb: 26, 26, 26;

            
            --pico-primary: #2563eb;
            --pico-secondary: #6b7280;
            --pico-primary-background: #2563eb;
            --pico-primary-inverse: #ffffff;
            --pico-primary-focus: rgba(37, 99, 235, 0.25);
            --pico-font-family: system-ui, -apple-system, sans-serif;
            --pico-border-radius: 6px;

            --ad: 0.6s;
            --overlay-rgb: 0,0,0;
        }

        
        #progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: var(--primary);
            width: 0%;
            z-index: 100;
            transition: width 0.3s ease;
        }

        #nav-controls {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            display: flex;
            gap: 1rem;
            z-index: 90;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #nav-controls:hover {
            opacity: 1;
        }

        #nav-controls button {
            background: var(--surface);
            border: 1px solid var(--secondary);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        #nav-controls button:hover {
            background: var(--primary);
            color: white;
            transform: scale(1.1);
            box-shadow: 0 8px 30px rgba(var(--prgb), 0.3);
        }

        #nav-controls button svg {
            transition: transform 0.3s ease;
        }

        #nav-controls button:active svg {
            transform: scale(0.9);
        }

        

        
        #loading-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--surface);
            border: 1px solid var(--secondary);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            z-index: 2000;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(var(--trgb), 0.3);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #loading-indicator p {
            margin: 0;
            color: var(--primary);
            font-weight: 600;
        }

        
        /* page gutter (left only on desktop so the TOC can stay flush right) */
        :root { --page-gutter: clamp(16px, 4vw, 48px); }

        .layout-wrapper,
        .grid-with-rail {
            display: grid;
            grid-template-columns: minmax(0, 1fr) max-content;
            gap: 1.25rem;
            align-items: start;
            width: 100%;
            padding-left: var(--page-gutter);   /* ← restore breathing room on the left */
            /* no right padding here, so the rail can hug the right edge */
        }

        
        .layout-wrapper > * {
            min-width: 0;
        }

        /* keep the text column from getting too wide; still left-aligned */
        #presentation-content.container {
            max-width: 90ch;           /* wider for better content density */
            justify-self: start;       /* stay left within the grid track */
            width: 100%;
        }

        /* Allow charts/images to be wider than the text measure */
        #presentation-content .mermaid,
        #presentation-content figure{
          max-width: 100%;
        }

        #toc-nav {
            position: sticky;
            top: 20px;
            justify-self: end;         /* push to the far right */
            width: max-content;        /* shrink-wrap to contents */
            max-width: 32ch;           /* cap so long items wrap nicely */
            padding: 0.4rem;

            max-height: calc(100vh - 40px);
            overflow-y: auto;
            overflow-x: hidden;
            box-sizing: border-box;

            /* never show a scrollbar, but keep wheel/touch scrolling */
            scrollbar-width: none;          /* Firefox */
            -ms-overflow-style: none;       /* old Edge/IE */
            overscroll-behavior: contain;   /* don't bubble to page */
            scrollbar-gutter: auto;         /* remove gutter reservation */
        }
        #toc-nav::-webkit-scrollbar { display: none; }  /* WebKit */

        
        #toc-nav h4 {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        #toc-nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: block;
        }
        
        #toc-nav li a {
            display: block;
            padding: 0.2rem 0.3rem;
            margin-bottom: 0.1rem;
            text-decoration: none;
            border-radius: var(--pico-border-radius);
            color: var(--text);
            transition: background-color 0.3s ease, color 0.3s ease;
            font-size: 0.7rem;
            font-weight: 500;
            line-height: 1.2;
            overflow-wrap: anywhere;
            word-break: break-word;
            white-space: normal;
            hyphens: none;
            border-left: 3px solid transparent;
            max-width: 100%;
            width: 100%;
            position: relative;
        }

        #toc-nav li a:hover {
            background-color: var(--surface);
        }

        #toc-nav li a.active {
            background-color: rgba(var(--prgb), 0.1);
            color: var(--primary);
            font-weight: 700;
            border-left-color: var(--primary);
        }
        
        
        #toc-nav > ul > li {
            position: relative;
        }

        #toc-nav ul ul {
            padding-left: 0.5rem;
            margin-top: 0.15rem;
            margin-bottom: 0.15rem;
            list-style: none;
            border-left: none;
        }

        
        #toc-nav ul ul::before,
        #toc-nav ul ul::after { content: none; }

        #toc-nav li ul li {
            position: relative;
            border-left: none;
        }

        
        #toc-nav li ul li::before,
        #toc-nav li ul li::after { content: none; }

        #toc-nav li a:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        #toc-nav li ul li a {
            font-size: 0.65rem;
            color: var(--text-secondary);
            padding: 0.15rem 0.3rem 0.15rem 0.5rem;
            margin-left: 0.2rem;
        }

        
        #toc-nav li ul li a.active {
             background-color: rgba(var(--prgb), 0.08);
             color: var(--primary);
             font-weight: 600;
        }

        
        .presentation-mode {
            background: var(--background);
        }

        /* Fullscreen keeps 2 columns and shows the TOC */
        .presentation-mode .layout-wrapper{
            grid-template-columns: minmax(0,1fr) max-content !important;
            max-width: none !important;
            padding-inline: var(--page-gutter);
        }

        /* Let the content column expand in fullscreen */
        .presentation-mode #presentation-content.container{
          max-width: clamp(72ch, 90vw, 1400px);
        }
        .presentation-mode #toc-nav{
            display: block !important;
            position: sticky;
            top: 16px;
            align-self: start;
            background: var(--surface);
            border: 1px solid var(--secondary);
            border-radius: var(--pico-border-radius);
            padding: .4rem;
            max-height: calc(100vh - 32px);
            overflow: auto;
        }

        .presentation-mode #nav-controls {
            opacity: 1 !important;
            z-index: 1000;
        }

        /* Sections should scroll naturally in fullscreen */
        .presentation-mode section{
            min-height: auto;
            display: block;
            align-items: flex-start;
            padding: 2rem 0;
        }

        /* Keep the hero tall if you like the opening slide feel */
        .presentation-mode .hero{
            min-height: 90vh;
            display: block;
            align-items: flex-start;
        }

        /* Optional: small screens can still hide the TOC in fullscreen */
        @media (max-width: 992px){
            .presentation-mode .layout-wrapper{ grid-template-columns: 1fr !important; }
            .presentation-mode #toc-nav{ display: none !important; }
        }

        /* Allow hiding the TOC on demand in both normal and fullscreen modes */
        body.toc-hidden #toc-nav{ display: none !important; }

        /* Improve Mermaid diagram height in fullscreen mode */
        .presentation-mode .mermaid {
            min-height: 0;         /* was 700px */
            padding: 1.25rem;      /* lighter padding so the chart can grow */
        }

        .presentation-mode .mermaid svg {
            min-height: 0;         /* allow natural sizing */
            height: auto;
        }

        @media (max-width: 992px) {
            .layout-wrapper,
            .grid-with-rail {
                grid-template-columns: 1fr;
                padding-inline: var(--page-gutter);  /* symmetric gutters on small screens */
            }
            #toc-nav {
                display: none;
            }
        }

        @media (max-width: 768px) {
            .presentation-mode .layout-wrapper {
                padding: 0 2rem;
            }

            .presentation-mode .hero h1 {
                font-size: 2.5rem;
            }
        }

        
        body {
            scroll-behavior: smooth;
            background: var(--background);
            color: var(--text);
        }

        .hero {
            text-align: center;
            padding: 6rem 2rem 4rem;
            margin-bottom: 3rem;
            background: linear-gradient(145deg, var(--background) 0%, var(--surface) 50%, var(--background) 100%);
            color: var(--text);
            position: relative;
            border-bottom: 3px solid var(--surface);
            box-shadow: 0 2px 20px rgba(0,0,0,0.08);
        }

        .hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                radial-gradient(circle at 20% 80%, rgba(var(--prgb), 0.04) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(var(--prgb), 0.03) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(var(--prgb), 0.02) 0%, transparent 50%);
            pointer-events: none;
        }

        .hero h1 {
            font-size: clamp(2rem, 4vw, 3rem);
            font-weight: 700;
            margin-bottom: 1.5rem;
            position: relative;
            z-index: 1;
            line-height: 1.1;
            letter-spacing: -0.02em;
            color: var(--text);
        }

        .hero p {
            font-size: clamp(1rem, 2vw, 1.2rem);
            color: var(--text-secondary);
            margin-bottom: 3rem;
            position: relative;
            z-index: 1;
            line-height: 1.6;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        
        .hero a[role="button"] {
            background: var(--primary);
            color: white;
            padding: 1.2rem 2.5rem;
            border-radius: 50px;
            font-weight: 600;
            text-decoration: none;
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
            box-shadow: 0 4px 15px rgba(var(--prgb), 0.3);
            border: 2px solid rgba(255,255,255,0.2);
            overflow: hidden;
        }

        .hero a[role="button"]::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .hero a[role="button"]:hover::before {
            left: 100%;
        }

        .hero a[role="button"]:hover {
            background: var(--primary);
            filter: brightness(1.1);
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(var(--prgb), 0.4);
        }

        .hero a[role="button"]:active {
            transform: translateY(-1px) scale(1.02);
        }

        
        .hero-highlights {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin: 3rem 0;
            flex-wrap: wrap;
        }

        .hero-highlight {
            background: var(--surface);
            backdrop-filter: blur(10px);
            border: 1px solid var(--secondary);
            border-radius: 16px;
            padding: 1.5rem;
            text-align: center;
            min-width: 120px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .hero-highlight:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.15);
        }

        .highlight-value {
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--primary) 0%, color-mix(in srgb, var(--primary) 80%, black) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .highlight-metric {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 0.25rem;
        }

        .highlight-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .hero-actions {
            margin-top: 2rem;
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .hero a[role="button"].btn-secondary {
            background: var(--surface);
            color: var(--primary);
            border: 2px solid var(--primary);
            box-shadow: 0 4px 15px rgba(var(--prgb), 0.2);
        }

        .hero a[role="button"].btn-secondary:hover {
            background: var(--primary);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(var(--prgb), 0.3);
        }

        .hero a[role="button"].btn-secondary::before {
            background: linear-gradient(90deg, transparent, rgba(var(--prgb), 0.3), transparent);
        }

        
        .hero a[role="button"].btn-secondary {
            animation: none;
        }


        
        @keyframes heroPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 4px 15px rgba(var(--prgb), 0.3);
            }
            50% {
                transform: scale(1.02);
                box-shadow: 0 6px 20px rgba(var(--prgb), 0.4);
            }
        }

        .hero a[role="button"] {
            animation: heroPulse 3s ease-in-out infinite;
        }

        .hero a[role="button"]:hover {
            animation: none;
        }

        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .hero .floating-element {
            animation: float 6s ease-in-out infinite;
        }

        .hero .floating-element:nth-child(2) {
            animation-delay: -2s;
        }

        .hero .floating-element:nth-child(3) {
            animation-delay: -4s;
        }

        
        @keyframes titleFadeIn {
            0% {
                opacity: 0;
                transform: translateY(30px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .hero h1 {
            animation: titleFadeIn 1s ease-out;
        }

        .hero p {
            animation: titleFadeIn 1s ease-out 0.3s both;
        }

        .hero-highlights {
            animation: titleFadeIn 1s ease-out 0.6s both;
        }

        .hero-actions {
            animation: titleFadeIn 1s ease-out 0.9s both;
        }

        
        @media (max-width: 768px) {
            .hero-highlights {
                gap: 1rem;
            }

            .hero-highlight {
                min-width: 100px;
                padding: 1rem;
            }

            .highlight-value {
                font-size: 1.2rem;
            }

            .hero-actions {
                flex-direction: column;
                align-items: center;
            }

            .hero a[role="button"] {
                min-width: 250px;
                text-align: center;
            }

            .kpi-card .value {
                font-size: 1.5rem;
            }
        }

        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .kpi-card {
            background: var(--surface);
            border: 1px solid var(--secondary);
            border-left: 5px solid var(--primary);
            padding: 2rem 1.5rem;
            border-radius: 16px;
            text-align: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
            /* enables cqi units to scale text by card width */
            container-type: inline-size;
        }

        .kpi-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--primary);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .kpi-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.15);
        }

        .kpi-card:hover::before {
            transform: scaleX(1);
        }

        /* VALUE */
        .kpi-card .value{
            font-weight: 800;
            line-height: 1.1;
            margin-bottom: 0.5rem;
            /* fluid, per-card sizing */
            font-size: clamp(1rem, 7cqi, 2rem);
            color: var(--primary);

            /* wrapping: never split words */
            white-space: normal;
            word-break: keep-all;
            overflow-wrap: normal;
            hyphens: none;
            text-wrap: balance;   /* nicer breaks; falls back below */

            /* multi-line clamp with ellipsis as last resort */
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 2;   /* allow up to 2 lines */
            line-clamp: 2;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* LABEL */
        .kpi-card .label{
            font-weight: 600;
            line-height: 1.2;
            margin-top: 0.5rem;
            /* fluid, per-card sizing */
            font-size: clamp(.85rem, 3.5cqi, 1rem);
            color: var(--text-secondary);

            white-space: normal;
            word-break: keep-all;
            overflow-wrap: normal;
            hyphens: none;
            text-wrap: pretty;

            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 2;   /* allow up to 2 lines */
            line-clamp: 2;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Fallback when container queries aren't supported */
        @supports not (container-type: inline-size){
            .kpi-card .value{ font-size: clamp(1rem, 4vw, 2rem); }
            .kpi-card .label{ font-size: clamp(.85rem, 2vw, 1rem); }
        }

        /* Admonitions — theme-aware, light/dark friendly */
        .admonition{
            --admon-accent: var(--primary);
            --admon-bg: color-mix(in srgb, var(--surface) 92%, transparent);
            --admon-border: color-mix(in srgb, var(--admon-accent) 25%, var(--secondary));

            border: 1px solid var(--admon-border);
            border-left: 8px solid var(--admon-accent);
            background: var(--admon-bg);
            border-radius: 12px;
            padding: 0.9rem 1rem;
            margin: 1rem 0;
            box-shadow: 0 2px 10px rgba(0,0,0,.05);
        }

        .admonition-head{
            display: flex; align-items: center; gap: .5rem;
            font-weight: 700; color: var(--admon-accent);
            margin-bottom: .35rem;
        }
        .admonition-head::before{
            content: "📝"; /* default icon (NOTE) */
            font-size: 1.1em; line-height: 1;
        }

        .admonition-body :is(p,ul,ol,pre,table,blockquote){ margin: .35rem 0; }
        .admonition-body > :first-child{ margin-top: 0; }
        .admonition-body > :last-child{ margin-bottom: 0; }

        /* Tone variants */
        .admonition.note{  --admon-accent: var(--primary); }
        .admonition.tip{   --admon-accent: #16a34a; }   /* green */
        .admonition.warn{  --admon-accent: #f59e0b; }   /* amber */
        .admonition.quote{ --admon-accent: #64748b; }   /* slate */

        /* Icons per variant (emoji = zero assets) */
        .admonition.tip   .admonition-head::before{ content: "💡"; }
        .admonition.warn  .admonition-head::before{ content: "⚠️"; }
        .admonition.quote .admonition-head::before{ content: "❝"; }

        /* Reduced motion & print-friendly */
        @media (prefers-reduced-motion: reduce){ .admonition{ box-shadow: none; } }
        @media print{ .admonition{ box-shadow: none; -webkit-print-color-adjust: exact; print-color-adjust: exact; } }

        section {
            padding: 3rem 0;
            border-bottom: 1px solid var(--pico-muted-border-color);
        }

        
        section[id],
        article.subsection[id] {
            scroll-margin-top: 28px;
        }

        
        .subsection {
            padding-left: 1.5rem;
            margin-top: 2.5rem;
            border-left: 2px solid var(--pico-muted-border-color);
        }
        
        section:last-of-type {
            border-bottom: none;
        }
        
        figure {
            margin: 2rem 0;
        }

        figure img {
            border-radius: var(--pico-border-radius);
            box-shadow: var(--pico-card-box-shadow);
            max-width: 100%;
            height: auto;
        }

        
        .animated-section {
            opacity: 0;
            transform: translateY(30px);
            transition: opacity var(--ad) ease-out, transform var(--ad) ease-out;
        }

        .animated-section.is-visible {
            opacity: 1;
            transform: translateY(0);
        }

        
        .mermaid {
            overflow-x: auto;
            background: var(--surface);
            border: 1px solid var(--secondary);
            border-radius: 16px;
            padding: 1.25rem;
            margin: 3rem 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.1),
                0 2px 8px rgba(0, 0, 0, 0.05);
            position: relative;
            display: flex;
            justify-content: center;
            min-height: 0;
        }


        
        .mermaid svg text,
        .mermaid svg tspan {
            font-family: var(--pico-font-family);
        }

        .mermaid::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary);
            border-radius: 16px 16px 0 0;
            opacity: 0.8;
        }

        .mermaid:hover {
            transform: translateY(-4px) scale(1.01);
            box-shadow:
                0 20px 60px rgba(0, 0, 0, 0.15),
                0 8px 24px rgba(0, 0, 0, 0.1);
            border-color: rgba(255, 255, 255, 0.25);
        }

        .mermaid:hover::before {
            opacity: 1;
            height: 4px;
        }

        .mermaid svg {
            display: block;
            max-width: 100%;
            height: auto;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: visible;
            margin-left: auto;
            margin-right: auto;
        }


        

        
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(var(--overlay-rgb), 0.72);
            backdrop-filter: blur(5px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            box-sizing: border-box;
        }

        #modal-overlay.show {
            display: flex;
        }

        #modal-content {
            background: transparent;
            border-radius: 0;
            max-width: 100vw;
            max-height: 100vh;
            overflow: hidden;
            position: relative;
            box-shadow: none;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        #modal-close {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: var(--pico-primary);
            color: var(--pico-primary-inverse);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
            z-index: 2001;
        }

        #modal-close:hover {
            background: var(--pico-primary-hover);
            transform: scale(1.1);
        }

        #modal-body {
            padding: 0;
            text-align: center;
            max-width: calc(100vw - 2rem);
            max-height: calc(100vh - 2rem);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #modal-body img {
            width: min(96vw, 1600px);
            max-height: 90vh;
            object-fit: contain;
            border-radius: var(--pico-border-radius);
        }

        #modal-body .mermaid-modal {
            background: var(--surface);
            border: 1px solid var(--secondary);
            border-radius: 20px;
            padding: 2rem;
            margin: 0;
            max-width: 98vw;           /* wider */
            max-height: 95vh;          /* taller */
            overflow: auto;
            box-shadow:
                0 25px 80px rgba(0, 0, 0, 0.2),
                0 0 0 1px var(--secondary);
            position: relative;
        }

        #modal-body .mermaid-modal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--primary);
            border-radius: 20px 20px 0 0;
        }

        #modal-body .mermaid-modal svg {
            width: min(96vw, 2000px) !important;  /* wider and higher limit */
            height: auto !important;
            display: block !important;
            margin: 0 auto !important;
            max-height: 90vh !important;           /* taller */
            visibility: visible !important;
            opacity: 1 !important;
            transition: all 0.3s ease;
        }

        
        figure img,
        .mermaid {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        figure img:hover,
        .mermaid:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        /* Keep legends readable regardless of theme */
        .mermaid g.legend text { fill: var(--text) !important; }
        .mermaid .legend rect { fill: var(--surface); stroke: var(--secondary); }

        
        dfn {
            text-decoration: underline dotted;
            text-decoration-color: var(--pico-primary);
            cursor: help;
            position: relative;
            font-style: normal;
        }

        dfn:hover::after {
            /* Disabled in favor of JS tooltip to prevent viewport overflow */
            content: none !important;
        }

        /* JS-driven glossary tooltip */
        #glossary-tooltip {
            position: fixed;
            max-width: min(320px, calc(100vw - 16px));
            padding: 0.5rem 0.75rem;
            background: var(--pico-primary);
            color: var(--pico-primary-inverse);
            border-radius: var(--pico-border-radius);
            font-size: 0.875rem;
            text-align: left;
            line-height: 1.4;
            z-index: 2002;
            box-shadow: var(--pico-card-box-shadow);
            display: none;
            pointer-events: none;
        }

        .glossary-list dt {
            font-weight: bold;
            color: var(--pico-primary);
        }

        .glossary-list dd {
            margin-left: 1rem;
            margin-bottom: 1rem;
            padding-left: 1rem;
            border-left: 2px solid var(--pico-muted-border-color);
        }

        .landing-hero {
            text-align: center;
            padding: 6rem 1rem 2rem;
            background: linear-gradient(180deg, color-mix(in srgb, var(--surface) 60%, transparent) 0%, transparent 100%);
            border-radius: var(--pico-border-radius);
        }
        .landing-brand {
            display: inline-block;
            font-weight: 800;
            letter-spacing: .02em;
            color: var(--primary);
            margin-bottom: .5rem;
        }
        .landing-sub {
            color: var(--text-secondary);
            margin: 0 auto 1.5rem;
            max-width: 60ch;
        }
        .landing-actions {
            display: flex; gap: .75rem; justify-content: center; flex-wrap: wrap; margin-top: 1rem;
        }

        .landing-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .lang-switch {
            display: flex;
            gap: 0.25rem;
            background: var(--surface);
            border: 1px solid var(--secondary);
            border-radius: var(--pico-border-radius);
            padding: 0.25rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .lang-btn {
            padding: 0.375rem 0.75rem;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            border-radius: calc(var(--pico-border-radius) - 2px);
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s ease;
            min-width: 2.5rem;
        }

        .lang-btn:hover {
            background: var(--primary);
            color: white;
        }

        .lang-btn.active {
            background: var(--primary);
            color: white;
            font-weight: 600;
        }

        
        .btn-primary, .btn-secondary {
            display: inline-block; padding: .75rem 1.25rem; border-radius: var(--pico-border-radius);
            text-decoration: none; border: 1px solid transparent; cursor: pointer;
        }
        .btn-primary { background: var(--primary); color: #fff; }
        .btn-primary:hover { filter: brightness(0.95); }
        .btn-secondary { background: var(--surface); color: var(--text); border-color: var(--secondary); }
        .btn-secondary:hover { background: color-mix(in srgb, var(--surface) 85%, var(--secondary)); }
        .info-chips { display: flex; gap: .5rem; justify-content: center; flex-wrap: wrap; margin-top: 1rem; }
        .chip { padding: .35rem .6rem; border: 1px solid var(--secondary); border-radius: 999px; font-size: .9rem; color: var(--text-secondary); }
        .feature-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1rem; margin: 2rem 0; }
        .card { background: var(--surface); border: 1px solid var(--secondary); border-radius: var(--pico-border-radius); padding: 1rem; }
        .fade-in { animation: fadeIn .4s ease both; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }

        /* Markdown HTML elements styling */
        ul, ol {
            padding-left: 1.5rem;
            margin: 1rem 0;
        }

        li {
            margin-bottom: 0.5rem;
            line-height: 1.6;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            background: var(--surface);
            border: 1px solid var(--secondary);
            border-radius: var(--pico-border-radius);
            overflow: hidden;
        }

        th, td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--secondary);
        }

        th {
            background: var(--primary);
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: rgba(var(--prgb), 0.05);
        }

        pre {
            background: var(--surface);
            border: 1px solid var(--secondary);
            border-radius: var(--pico-border-radius);
            padding: 1rem;
            overflow-x: auto;
            margin: 1rem 0;
        }

        code {
            background: var(--surface);
            border: 1px solid var(--secondary);
            border-radius: 0.25rem;
            padding: 0.125rem 0.25rem;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.875em;
        }

        pre code {
            border: none;
            background: transparent;
            padding: 0;
        }

        hr {
            border: none;
            border-top: 2px solid var(--secondary);
            margin: 2rem 0;
        }

        strong {
            font-weight: 700;
            color: var(--primary);
        }

        em {
            font-style: italic;
            color: var(--text-secondary);
        }

        del {
            text-decoration: line-through;
            opacity: 0.7;
        }

    </style>
</head>
<body>
    
    
    <div id="progress-bar"></div>
    

    
    <div id="nav-controls">
        <button id="upload-json" aria-label="Upload JSON file" title="Upload JSON (Ctrl+U)">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14,2 14,8 20,8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10,9 9,9 8,9"></polyline>
            </svg>
        </button>
        <button id="theme-toggle" aria-label="Toggle theme" title="Toggle Light/Dark Mode (T)">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 2.25a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zM7.5 12a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM18.894 6.166a.75.75 0 00-1.06-1.06l-1.591 1.59a.75.75 0 101.06 1.061l1.591-1.59zM21.75 12a.75.75 0 01-.75.75h-2.25a.75.75 0 010-1.5H21a.75.75 0 01.75.75zM17.834 18.894a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 10-1.061 1.06l1.59 1.591zM12 18a.75.75 0 01.75.75V21a.75.75 0 01-1.5 0v-2.25A.75.75 0 0112 18zM7.758 17.303a.75.75 0 00-1.061-1.06l-1.591 1.59a.75.75 0 001.06 1.061l1.591-1.59zM6 12a.75.75 0 01-.75.75H3a.75.75 0 010-1.5h2.25A.75.75 0 016 12zM6.697 7.757a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 00-1.061 1.06l1.59 1.591z"></path>
            </svg>
        </button>
        <button id="fullscreen-toggle" aria-label="Toggle fullscreen" title="Fullscreen (F)">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
            </svg>
        </button>
        <button id="prev-section" aria-label="Previous section" title="Previous (←)">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15,18 9,12 15,6"></polyline>
            </svg>
        </button>
        <button id="next-section" aria-label="Next section" title="Next (→)">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="9,18 15,12 9,6"></polyline>
            </svg>
        </button>
        <button id="toc-toggle" aria-label="Toggle table of contents" title="Toggle TOC (H) - Works in both normal and fullscreen modes">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="4" width="8" height="16"></rect>
                <rect x="13" y="4" width="8" height="3"></rect>
                <rect x="13" y="9" width="8" height="3"></rect>
                <rect x="13" y="14" width="8" height="6"></rect>
            </svg>
        </button>
    </div>

    
    <input type="file" id="json-file-input" accept=".json,.md" style="display: none;">

    
    <div id="loading-indicator" style="display: none;">
        <div class="loading-spinner"></div>
        <p>Loading presentation...</p>
    </div>

    <div class="layout-wrapper grid-with-rail">
        <main id="presentation-content" class="container"></main>

        <aside id="toc-nav" role="navigation" aria-label="Table of contents">
            <ul id="toc-list"></ul>
        </aside>
    </div>

    
    <div id="modal-overlay">
        <div id="modal-content">
            <button id="modal-close" aria-label="Fermer">&times;</button>
            <div id="modal-body">
                
            </div>
        </div>
    </div>


    

    <script src="vendor/mermaid.min.js"></script>
    <script src="vendor/marked.min.js"></script>

    <script>
            const config = {
                contentEl: document.getElementById('presentation-content'),
                tocEl: document.getElementById('toc-list'),
                progressBarEl: document.getElementById('progress-bar'),
            };

            // Global variable to store current presentation data
            let currentPresentationData = null;

            // Navigation mode state (linear only)
            const currentNavigationMode = 'linear';

            // AbortController for cleaning up event listeners on reload
            let abortController = new AbortController();

            // Theme engine (single source of truth)
            const Theme = (() => {
                const listeners = new Set();
                let mode = 'light';

                function getPalette(pd, which) {
                    const base = pd?.theme?.colors?.[which] || {};
                    return {
                        primary:        base.primary        || '#2563eb',
                        secondary:      base.secondary      || '#6b7280',
                        background:     base.background     || (which === 'dark' ? '#1a1a1a' : '#ffffff'),
                        surface:        base.surface        || (which === 'dark' ? '#2a2a2a' : '#f8f9fa'),
                        text:           base.text           || (which === 'dark' ? '#ffffff' : '#1a1a1a'),
                        textSecondary:  base['text-secondary'] || (which === 'dark' ? '#a1a1aa' : '#6c757d')
                    };
                }

                const toRgb = (hex) => {
                    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(String(hex).trim());
                    if (!m) return '0,0,0';
                    return `${parseInt(m[1],16)}, ${parseInt(m[2],16)}, ${parseInt(m[3],16)}`;
                };

                function applyCss(p) {
                    const root = document.documentElement;
                    root.setAttribute('data-theme', mode);
                    root.style.setProperty('--primary', p.primary);
                    root.style.setProperty('--secondary', p.secondary);
                    root.style.setProperty('--background', p.background);
                    root.style.setProperty('--surface', p.surface);
                    root.style.setProperty('--text', p.text);
                    root.style.setProperty('--text-secondary', p.textSecondary);
                    root.style.setProperty('--prgb', toRgb(p.primary));
                    root.style.setProperty('--srgb', toRgb(p.secondary));
                    root.style.setProperty('--trgb', toRgb(p.text));
                    // Pico compat
                    root.style.setProperty('--pico-primary', p.primary);
                    root.style.setProperty('--pico-secondary', p.secondary);
                    root.style.setProperty('--pico-primary-background', p.primary);
                    root.style.setProperty('--pico-primary-inverse', '#fff');
                    root.style.setProperty('--pico-primary-focus', `rgba(${toRgb(p.primary)}, .25)`);
                    root.style.setProperty('--pico-primary-hover', `color-mix(in srgb, ${p.primary} 90%, black)`);
                    root.style.setProperty('--pico-h5-color', p.text);
                    root.style.setProperty('--pico-muted-border-color', p.secondary);
                    root.style.setProperty('--pico-del-color', p.primary);
                    root.style.setProperty('--pico-code-background-color', p.surface);
                    root.style.setProperty('--pico-code-border-color', p.secondary);
                }

                async function apply(pd = window.currentPresentationData) {
                    applyCss(getPalette(pd, mode));
                    await new Promise(r => requestAnimationFrame(r));
                    listeners.forEach(fn => fn({ mode }));
                }

                async function setMode(next, pd = window.currentPresentationData) {
                    mode = next === 'dark' ? 'dark' : 'light';
                    localStorage.setItem('theme', mode);
                    await apply(pd);
                }

                async function init(pd) {
                    const saved = localStorage.getItem('theme');
                    mode = (saved === 'light' || saved === 'dark') ? saved : (pd?.theme?.mode || 'light');
                    return apply(pd);
                }

                function onChange(fn){ listeners.add(fn); return () => listeners.delete(fn); }

                return { get mode(){return mode;}, init, setMode, onChange, apply };
            })();

            // Unified Mermaid config builder
            function buildMermaidConfig() {
                const s = getComputedStyle(document.documentElement);
                const val = (v, fb) => s.getPropertyValue(v).trim() || fb;
                const dark = Theme.mode === 'dark';

                let base = {
                    startOnLoad: false,
                    securityLevel: 'strict',
                    theme: (window.currentPresentationData?.mermaid?.theme) || (dark ? 'dark' : 'default'),
                    fontFamily: (window.currentPresentationData?.mermaid?.fontFamily) || 'system-ui, -apple-system, sans-serif',
                    flowchart: { useMaxWidth: true, htmlLabels: false, curve: 'basis', padding: 16, nodeSpacing: 60, rankSpacing: 70 },
                    sequence:  { useMaxWidth: true, htmlLabels: false, diagramMarginX: 50, diagramMarginY: 20 },
                    gantt:     { useMaxWidth: true, htmlLabels: false, barHeight: 32, barGap: 12, topPadding: 60, leftPadding: 120, axisFormat: '%m-%d' },
                    pie:       { useMaxWidth: true, htmlLabels: false },
                    themeVariables: {
                        primaryColor:        val('--primary', '#2563eb'),
                        primaryTextColor:    val('--text', '#1a1a1a'),
                        primaryBorderColor:  val('--primary', '#2563eb'),
                        lineColor:           val('--primary', '#2563eb'),
                        sectionBkgColor:     val('--surface', dark ? '#2a2a2a' : '#f8f9fa'),
                        altSectionBkgColor:  val('--background', dark ? '#1a1a1a' : '#ffffff'),
                        gridColor:           val('--secondary', '#6b7280'),
                        edgeLabelBackground: val('--surface', dark ? '#2a2a2a' : '#f8f9fa'),
                        fontSize: '16px',
                        pieTitleTextSize: '22px',
                        pieSectionTextSize: '16px',
                        pieLegendTextSize: '14px',
                        ganttBarHeight: 32, ganttBarGap: 12, ganttLeftPadding: 120
                    }
                };

                // ⬇️ bring in deck overrides from schema's mermaid.config (whitelisted)
                const deckCfg = window.currentPresentationData?.mermaid?.config;
                if (deckCfg) base = deepMergeAllowed(base, deckCfg);

                return base;
            }

            // Simple translation dictionary for landing page
            const translations = {
                en: {
                    title: "Load Your Presentation",
                    subtitle: "Local, secure, and fully open source. Supports JSON & Markdown with rich formatting. No servers. No tracking. Works on GitHub Pages.",
                    select: "Select File",
                    github: "View on GitHub",
                    chipLocal: "🔒 All local",
                    chipJson: "🧩 JSON & Markdown",
                    chipMarkdown: "📝 Rich formatting",
                    chipMermaid: "🖼️ Mermaid supported",
                    chipLicense: "📄 MIT License",
                    howTitle: "How it works",
                    howCopy: "Click <strong>Select File</strong> to render your presentation instantly. Supports JSON and Markdown files with full formatting—all local in your browser.",
                    secTitle: "Security",
                    secCopy: "Everything runs in your browser. No data leaves your machine. External links open in a new tab with <code>rel=\"noopener\"</code>.",
                    markdownTitle: "Markdown Support",
                    markdownCopy: "Write presentations naturally with full Markdown formatting: <strong>bold</strong>, <em>italic</em>, lists, tables, code blocks, and more. Front matter supports themes, navigation, and glossary.",
                    licTitle: "License",
                    licCopy: "Distributed under the <strong>MIT License</strong>. See <a href=\"LICENSE\" target=\"_blank\" rel=\"noopener\">LICENSE</a> for details."
                },
                fr: {
                    title: "Chargez votre présentation",
                    subtitle: "Local, sécurisé et entièrement open source. Supporte JSON & Markdown avec formatage riche. Aucun serveur. Aucun suivi. Fonctionne sur GitHub Pages.",
                    select: "Sélectionner un fichier",
                    github: "Voir sur GitHub",
                    chipLocal: "🔒 Tout local",
                    chipJson: "🧩 JSON & Markdown",
                    chipMarkdown: "📝 Formatage riche",
                    chipMermaid: "🖼️ Mermaid supporté",
                    chipLicense: "📄 Licence MIT",
                    howTitle: "Comment ça marche",
                    howCopy: "Cliquez sur <strong>Sélectionner un fichier</strong> pour rendre votre présentation instantanément. Supporte les fichiers JSON et Markdown avec formatage complet—tout fonctionne localement dans votre navigateur.",
                    secTitle: "Sécurité",
                    secCopy: "Tout fonctionne dans votre navigateur. Aucune donnée ne quitte votre machine. Les liens externes s'ouvrent dans un nouvel onglet avec <code>rel=\"noopener\"</code>.",
                    markdownTitle: "Support Markdown",
                    markdownCopy: "Écrivez vos présentations naturellement avec le formatage Markdown complet : <strong>gras</strong>, <em>italique</em>, listes, tableaux, blocs de code, et plus encore. Le front matter supporte les thèmes, la navigation et le glossaire.",
                    licTitle: "Licence",
                    licCopy: "Distribué sous la <strong>licence MIT</strong>. Voir <a href=\"LICENSE\" target=\"_blank\" rel=\"noopener\">LICENSE</a> pour les détails."
                }
            };

            // Current language for landing page (independent of presentation)
            let currentLandingLanguage = 'fr'; // Default to French to match the page

            // Throttle utility function for scroll performance
            function throttle(func, limit) {
                let inThrottle;
                return function() {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                }
            }

            // Slugify helper for generating IDs from headings
            function slugify(text) {
                return text
                    .toString()
                    .toLowerCase()
                    .trim()
                    .replace(/\s+/g, '-')
                    .replace(/[^\w\-]+/g, '')
                    .replace(/\-\-+/g, '-')
                    .replace(/^-+/, '')
                    .replace(/-+$/, '');
            }

            /**
             * Utility: Detects invalid CSS values (e.g., undefined/null/empty/NaN strings)
             */
            function isInvalidCssValue(value) {
                if (value === undefined || value === null) return true;
                const v = (typeof value === 'string' ? value : String(value)).trim();
                return v === '' || v === 'undefined' || v === 'null' || v === 'NaN';
            }

            /**
             * Utility: Safely set a CSS variable only if the value is valid
             */
            function safeSetCssVar(varName, value) {
                if (!isInvalidCssValue(value)) {
                    document.documentElement.style.setProperty(varName, value);
                }
            }

            /**
             * Applies translations to landing page elements
             */
            function applyLandingTranslations(language) {
                const langData = translations[language];
                if (!langData) return;

                // Update all elements with data-i18n attributes
                document.querySelectorAll('[data-i18n]').forEach(element => {
                    const key = element.getAttribute('data-i18n');
                    if (langData[key]) {
                        if (element.tagName === 'INPUT' && element.type === 'submit') {
                            element.value = langData[key];
                        } else {
                            element.innerHTML = langData[key];
                        }
                    }
                });

                // Update language button states
                document.querySelectorAll('.lang-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.getAttribute('data-lang') === language);
                });

                // Store preference
                localStorage.setItem('landing-language', language);
            }

            /**
             * Sets up landing page language toggle
             */
            function setupLandingLanguageToggle() {
                const langBtns = document.querySelectorAll('.lang-btn');

                langBtns.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const lang = btn.getAttribute('data-lang');
                        if (lang && translations[lang]) {
                            currentLandingLanguage = lang;
                            applyLandingTranslations(lang);
                        }
                    });
                });

                // Load saved preference
                const savedLang = localStorage.getItem('landing-language');
                if (savedLang && translations[savedLang]) {
                    currentLandingLanguage = savedLang;
                    applyLandingTranslations(savedLang);
                } else {
                    // Apply default language
                    applyLandingTranslations(currentLandingLanguage);
                }
            }

            

            /**
             * Handles uploaded presentation files (local only)
             */
            async function handleFile(file) {
                const text = await readFileAsText(file);
                const isMd = file.name.toLowerCase().endsWith('.md');
                const data = isMd ? parseMarkdownToPresentation(text) : JSON.parse(text);
                await init(data);
            }

            /**
             * Parses Markdown with JSON front matter into presentation data structure
             */
            function parseMarkdownToPresentation(mdText) {
                let frontMatter = {};
                let bodyMd = mdText;

                // Extract front matter from first fenced block with 'frontmatter' in info
                // Tolerate 3+ backticks/tilde fences and optional whitespace
                const frontMatterMatch = mdText.match(/^([`~]{3,})\s*(?:json\s+)?frontmatter\s*\n([\s\S]*?)\n\1\s*(?:\n|$)/m);
                if (frontMatterMatch) {
                    try {
                        frontMatter = JSON.parse(frontMatterMatch[2]);
                        bodyMd = mdText.replace(frontMatterMatch[0], '');
                    } catch (e) {
                        console.warn('Invalid front matter JSON:', e);
                    }
                }

                // Tokenize the Markdown body with inline parsing enabled
                const tokens = marked.lexer(bodyMd, {
                    gfm: true,
                    breaks: true,
                    mangle: false,
                    pedantic: false,
                    smartLists: true,
                    smartypants: false
                });
                const sections = [];
                let currentSection = null;
                let currentSubsection = null;

                tokens.forEach(token => {
                    if (token.type === 'heading') {
                        const level = token.depth;
                        const text = token.text.trim();
                        let id = '';

                        // Check for explicit ID at end {#id}
                        const idMatch = text.match(/\{#([^}]+)\}$/);
                        if (idMatch) {
                            id = idMatch[1];
                            token.text = text.replace(/\{#[^}]+\}$/, '').trim();
                        } else {
                            id = slugify(text);
                        }

                        if (level === 2) {
                            // Section
                            if (currentSection) {
                                sections.push(currentSection);
                            }
                            currentSection = {
                                id: id,
                                title: token.text,
                                content: [],
                                subsections: []
                            };
                            currentSubsection = null;
                        } else if (level === 3 && currentSection) {
                            // Subsection
                            currentSubsection = {
                                id: id,
                                title: token.text,
                                content: []
                            };
                            currentSection.subsections.push(currentSubsection);
                        }
                    } else if (currentSection) {
                        // Content blocks
                        const block = convertTokenToBlock(token);
                        if (block) {
                            if (currentSubsection) {
                                currentSubsection.content.push(block);
                            } else {
                                currentSection.content.push(block);
                            }
                        }
                    }
                });

                // Push the last section
                if (currentSection) {
                    sections.push(currentSection);
                }

                return {
                    title: frontMatter.title || 'Presentation',
                    theme: frontMatter.theme,
                    navigation: frontMatter.navigation,
                    hero: frontMatter.hero,
                    glossary: frontMatter.glossary,
                    sections: sections
                };
            }

            /**
             * Renders a token back to HTML while preserving formatting
             */
            function renderTokenToHTML(token) {
                if (!token) return '';

                switch (token.type) {
                    case 'text':
                        return token.text;
                    case 'strong':
                        return `<strong>${renderTokensToHTML(token.tokens)}</strong>`;
                    case 'em':
                        return `<em>${renderTokensToHTML(token.tokens)}</em>`;
                    case 'del':
                        return `<del>${renderTokensToHTML(token.tokens)}</del>`;
                    case 'codespan':
                        return `<code>${token.text}</code>`;
                    case 'link':
                        const attrs = token.href.startsWith('http') ? ' target="_blank" rel="noopener"' : '';
                        return `<a href="${token.href}"${attrs}>${renderTokensToHTML(token.tokens)}</a>`;
                    case 'image':
                        return `<img src="${token.href}" alt="${token.text}" title="${token.title || ''}">`;
                    case 'br':
                        return '<br>';
                    default:
                        if (token.tokens) {
                            return renderTokensToHTML(token.tokens);
                        }
                        return token.raw || token.text || '';
                }
            }

            /**
             * Renders an array of tokens to HTML
             */
            function renderTokensToHTML(tokens) {
                if (!tokens || !Array.isArray(tokens)) return '';
                return tokens.map(renderTokenToHTML).join('');
            }

            /**
             * Converts a Markdown token to a presentation block
             */
            function convertTokenToBlock(token) {
                switch (token.type) {
                    case 'paragraph':
                        // Check for glossary placeholder
                        if (token.text.includes('[[glossary]]')) {
                            return { type: 'glossary' };
                        }
                        // Check if paragraph contains only an image using regex
                        const imageRegex = /^!\[([^\]]*)\]\(([^)\s]+)(?:\s+"([^"]*)")?\)\s*$/;
                        const imageMatch = token.text.match(imageRegex);
                        if (imageMatch) {
                            return {
                                type: 'image',
                                value: {
                                    src: imageMatch[2],
                                    alt: imageMatch[1],
                                    caption: imageMatch[3] || ''
                                }
                            };
                        }
                        // For regular paragraphs, preserve HTML formatting
                        return { type: 'paragraph', value: renderTokenToHTML(token) };

                    case 'blockquote': {
                        // Parse admonitions directly from raw Markdown lines inside the blockquote
                        const raw = (token.raw || '').replace(/^\n+|\n+$/g, '');
                        const lines = raw.split(/\r?\n/).map(l => l.replace(/^\s{0,3}>\s?/, ''));

                        // Find first non-empty line after removing ">" prefix
                        let firstIndex = 0;
                        while (firstIndex < lines.length && lines[firstIndex].trim() === '') firstIndex++;

                        const firstLine = lines[firstIndex] || '';
                        const m = /^\s*\[\!(NOTE|TIP|WARN|QUOTE)\]\s*:\s*(.*)$/i.exec(firstLine);
                        if (m) {
                            const kind = m[1].toLowerCase();
                            const headRaw = (m[2] || '').trim();
                            const safeHead = headRaw.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

                            const bodyMd = lines.slice(firstIndex + 1).join('\n').trim();
                            const bodyHtml = bodyMd ? marked.parse(bodyMd).trim() : '';

                            return {
                                type: 'html',
                                value: `
                                    <div class="admonition ${kind}" role="note" aria-label="${kind}">
                                        <div class="admonition-head">${safeHead}</div>
                                        <div class="admonition-body">${bodyHtml}</div>
                                    </div>
                                `
                            };
                        }

                        // Fallback: treat as a regular blockquote
                        const parsed = marked.parse(token.raw).trim();
                        const innerMatch = /^<blockquote>([\s\S]*)<\/blockquote>\s*$/i.exec(parsed);
                        const innerHtml = innerMatch ? innerMatch[1] : parsed;
                        return { type: 'blockquote', value: { text: innerHtml, cite: '' } };
                    }

                    case 'list':
                        // Delegate full list rendering (including nesting and inline styles) to Marked
                        // Using token.raw preserves the exact structure and avoids manual reconstruction issues
                        return { type: 'html', value: marked.parse(token.raw) };

                    case 'table':
                        const headerRow = token.header.map(cell => `<th>${marked.parseInline(cell.raw || cell.text || '')}</th>`).join('');
                        const bodyRows = token.rows.map(row =>
                            `<tr>${row.map(cell => `<td>${marked.parseInline(cell.raw || cell.text || '')}</td>`).join('')}</tr>`
                        ).join('');
                        return {
                            type: 'html',
                            value: `<table><thead><tr>${headerRow}</tr></thead><tbody>${bodyRows}</tbody></table>`
                        };

                    case 'code':
                        if (token.lang === 'mermaid') {
                            return { type: 'mermaid', value: token.text };
                        } else if (token.lang === 'kpi-grid') {
                            try {
                                const data = JSON.parse(token.text);
                                return { type: 'kpi-grid', value: data };
                            } catch (e) {
                                console.warn('Invalid KPI grid JSON:', e);
                            }
                        } else if (token.lang === 'glossary') {
                            return { type: 'glossary' };
                        } else {
                            // Generic code block
                            const lang = token.lang ? ` class="language-${token.lang}"` : '';
                            return { type: 'html', value: `<pre><code${lang}>${token.text}</code></pre>` };
                        }
                        break;

                    case 'hr':
                        // Sections already have a border-bottom; suppress raw <hr> to avoid double lines
                        return null;
                }
                return null;
            }

            /**
             * Processes navigation configuration and reorders content if needed (linear mode only)
             */
            function processNavigationOrder(data, targetMode = null) {
                const mode = targetMode || data.navigation?.mode || 'linear';

                if (mode === 'linear') {
                    return data; // No changes needed
                }

                if (mode === 'ordered' && data.navigation?.order) {
                    return reorderContentByArray(data, data.navigation.order);
                }

                return data; // Fallback to linear
            }

            /**
             * Helper function to reorder content based on an array of IDs
             */
            function reorderContentByArray(data, orderArray) {
                // Create a map of all sections and subsections by ID
                const contentMap = new Map();
                data.sections.forEach(section => {
                    contentMap.set(section.id, { type: 'section', data: section });
                    if (section.subsections) {
                        section.subsections.forEach(sub => {
                            contentMap.set(sub.id, { type: 'subsection', data: sub, parentId: section.id });
                        });
                    }
                });

                // Reorder sections and subsections according to orderArray
                const orderedSections = [];
                const processedIds = new Set();

                orderArray.forEach(id => {
                    const item = contentMap.get(id);
                    if (item) {
                        if (item.type === 'section') {
                            // Create a copy of the section
                            const sectionCopy = { ...item.data };

                            // If section has subsections, reorder them according to orderArray
                            if (sectionCopy.subsections && orderArray) {
                                const orderedSubs = [];
                                orderArray.forEach(subId => {
                                    const subItem = contentMap.get(subId);
                                    if (subItem && subItem.type === 'subsection' && subItem.parentId === id) {
                                        orderedSubs.push(subItem.data);
                                        processedIds.add(subId);
                                    }
                                });
                                // Add any remaining subsections not in navigation order
                                if (sectionCopy.subsections) {
                                    sectionCopy.subsections.forEach(sub => {
                                        if (!processedIds.has(sub.id)) {
                                            orderedSubs.push(sub);
                                        }
                                    });
                                }
                                sectionCopy.subsections = orderedSubs;
                            }

                            orderedSections.push(sectionCopy);
                            processedIds.add(id);
                        } else if (item.type === 'subsection') {
                            // Handle standalone subsections (though this is rare)
                            // For now, we'll skip them as they should be handled within their parent sections
                        }
                    }
                });

                // Add any sections not in the navigation order
                data.sections.forEach(section => {
                    if (!processedIds.has(section.id)) {
                        orderedSections.push(section);
                    }
                });

                return { ...data, sections: orderedSections };
            }

            /**
             * Renders the landing page
             */
            function renderLanding() {
                const repoUrl = getGitHubRepoUrl();
                config.contentEl.innerHTML = `
                    <section class="landing-hero fade-in">
                        <div class="landing-controls">
                            <div class="lang-switch" role="group" aria-label="Language">
                                <button class="lang-btn" data-lang="en">EN</button>
                                <button class="lang-btn" data-lang="fr">FR</button>
                            </div>
                        </div>
                        <div class="landing-brand">📑 Narrative Presentation</div>
                        <h1 data-i18n="title">Load Your Presentation</h1>
                        <p class="landing-sub" data-i18n="subtitle">Local, secure, and fully open source. Supports JSON & Markdown with rich formatting. No servers. No tracking. Works on GitHub Pages.</p>
                        <div class="landing-actions">
                            <input type="file" id="fallback-json-input" accept=".json,.md" style="display:none;">
                            <button id="fallback-upload-btn" class="btn-primary" data-i18n="select">Select File</button>
                            ${repoUrl ? `<a href="${repoUrl}" target="_blank" rel="noopener" class="btn-secondary" data-i18n="github">View on GitHub</a>` : ''}
                            <a href="README.md" target="_blank" rel="noopener" class="btn-secondary">README</a>
                        </div>
                        <div class="info-chips">
                            <span class="chip" data-i18n="chipLocal">🔒 All local</span>
                            <span class="chip" data-i18n="chipJson">🧩 JSON & Markdown</span>
                            <span class="chip" data-i18n="chipMarkdown">📝 Rich formatting</span>
                            <span class="chip" data-i18n="chipMermaid">🖼️ Mermaid supported</span>
                            <span class="chip" data-i18n="chipLicense">📄 MIT License</span>
                        </div>
                    </section>

                    <section class="feature-grid fade-in" style="animation-delay: .1s;">
                        <article class="card">
                            <h3 data-i18n="howTitle">How it works</h3>
                            <p data-i18n="howCopy">Click <strong>Select File</strong> to render your presentation instantly. Supports JSON and Markdown files with full formatting—all local in your browser.</p>
                        </article>
                        <article class="card">
                            <h3 data-i18n="secTitle">Security</h3>
                            <p data-i18n="secCopy">Everything runs in your browser. No data leaves your machine. External links open in a new tab with <code>rel=\"noopener\"</code>.</p>
                        </article>
                        <article class="card">
                            <h3 data-i18n="markdownTitle">📝 Markdown Support</h3>
                            <p data-i18n="markdownCopy">Write presentations naturally with full Markdown formatting: <strong>bold</strong>, <em>italic</em>, lists, tables, code blocks, and more. Front matter supports themes, navigation, and glossary.</p>
                        </article>
                        <article class="card">
                            <h3 data-i18n="licTitle">License</h3>
                            <p data-i18n="licCopy">Distributed under the <strong>MIT License</strong>. See <a href=\"LICENSE\" target=\"_blank\" rel=\"noopener\">LICENSE</a> for details.</p>
                        </article>
                    </section>
                `;
            }

            /**
             * Main function to initialize the presentation
             */
            async function init(uploadedData = null) {
                if (!uploadedData) {
                    renderLanding();
                    setupLandingLanguageToggle();
                    setupFallbackUpload();
                    setupFileUpload();
                    return;
                }

                try {
                    const processedData = processNavigationOrder(uploadedData);
                    currentPresentationData = processedData;
                    await Theme.init(processedData);
                    document.title = processedData.title || 'Presentation';

                    renderPresentation(processedData);
                    processGlossary(processedData.glossary);
                    MermaidManager.initAll();
                    setupEventListeners(processedData.sections);
                    setTimeout(setupInteractiveElements, 100);
                } catch (error) {
                    alert(`Error loading presentation file: ${error.message}`);
                    renderLanding();
                    setupLandingLanguageToggle();
                    setupFallbackUpload();
                    setupFileUpload();
                }
            }

            /**
             * Sets up fallback upload functionality when presentation.json is not found
             */
            function setupFallbackUpload() {
                const uploadBtn = document.getElementById('fallback-upload-btn');
                const fileInput = document.getElementById('fallback-json-input');

                if (!uploadBtn || !fileInput) return;

                uploadBtn.addEventListener('click', () => {
                    fileInput.click();
                });

                fileInput.addEventListener('change', async (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    const fileName = file.name.toLowerCase();
                    if (!fileName.endsWith('.json') && !fileName.endsWith('.md')) {
                        alert('Please select a JSON or Markdown file.');
                        return;
                    }

                    try {
                        uploadBtn.textContent = 'Loading...';
                        uploadBtn.disabled = true;

                        const fileContent = await readFileAsText(file);
                        let data;

                        if (fileName.endsWith('.md')) {
                            // Parse Markdown
                            data = parseMarkdownToPresentation(fileContent);
                        } else {
                            // Parse JSON
                            data = JSON.parse(fileContent);
                            // Validate basic structure
                            if (!data.title || !data.sections) {
                                throw new Error('Invalid presentation format. Missing required fields (title, sections).');
                            }
                        }

                        // Initialize with uploaded data (navigation processing happens in init)
                        await init(data);
                    } catch (err) {
                        alert(err.message || 'Failed to load the selected file.');
                    } finally {
                        uploadBtn.textContent = 'Upload JSON';
                        uploadBtn.disabled = false;
                        fileInput.value = '';
                    }
                });
            }

            function getGitHubRepoUrl() {
                if (window.GITHUB_REPO_URL) return window.GITHUB_REPO_URL;
                const { host, pathname } = window.location;
                if (!host.endsWith('github.io')) return '';
                const parts = pathname.split('/').filter(Boolean);
                const user = host.split('.')[0];
                const repo = parts.length > 0 ? parts[0] : '';
                if (!user || !repo) return '';
                return `https://github.com/${user}/${repo}`;
            }

            /**
             * Reloads the presentation with new data
             */
            async function reloadPresentation(newData) {
                try {
                    // Clean up previous event listeners
                    abortController.abort();
                    abortController = new AbortController();

                    // Clear existing content
                    config.contentEl.innerHTML = '';
                    config.tocEl.innerHTML = '';

                    // Process navigation order and reinitialize
                    const processedData = processNavigationOrder(newData);
                    currentPresentationData = processedData;

                    if (processedData.theme?.mode) {
                        await Theme.setMode(processedData.theme.mode, processedData);
                    } else {
                        await Theme.init(processedData);
                    }
                    document.title = processedData.title;

                    renderPresentation(processedData);
                    processGlossary(processedData.glossary);
                    MermaidManager.initAll();
                    setupEventListeners(processedData.sections);

                    // Setup interactive elements after content is loaded
                    setTimeout(() => {
                        setupInteractiveElements();
                    }, 100);
                } catch (error) { alert('Error loading the presentation file. Please check the JSON format.'); }
            }
            
            /**
             * Helper function to convert hex color to RGB values
             */
            function hexToRgb(hex) {
                if (!hex) return '37, 99, 235';
                const input = String(hex).trim();
                // Handle rgb()/rgba()
                if (/^rgba?\(/i.test(input)) {
                    try {
                        const parts = input
                            .replace(/^rgba?\(/i, '')
                            .replace(/\)\s*$/i, '')
                            .split(',')
                            .map(p => parseFloat(p.trim()));
                        const r = Math.round(parts[0] || 0);
                        const g = Math.round(parts[1] || 0);
                        const b = Math.round(parts[2] || 0);
                        return `${r}, ${g}, ${b}`;
                    } catch (_) {
                        return '37, 99, 235';
                    }
                }
                // Handle #rgb and #rrggbb
                const short = /^#?([a-f\d])([a-f\d])([a-f\d])$/i.exec(input);
                if (short) {
                    const r = parseInt(short[1] + short[1], 16);
                    const g = parseInt(short[2] + short[2], 16);
                    const b = parseInt(short[3] + short[3], 16);
                    return `${r}, ${g}, ${b}`;
                }
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(input);
                return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '37, 99, 235';
            }


            /**
             * Renders the entire presentation structure from JSON data
             */
            function renderPresentation(data) {
                let html = '';
                // Render Hero
                if (data.hero) {
                    let highlightsHtml = '';
                    if (data.hero.highlights && data.hero.highlights.length > 0) {
                        highlightsHtml = '<div class="hero-highlights">';
                        data.hero.highlights.forEach((highlight, index) => {
                            highlightsHtml += `
                                <div class="hero-highlight floating-element" style="animation-delay: ${index * 0.5}s">
                                    <div class="highlight-value">${highlight.value}</div>
                                    <div class="highlight-metric">${highlight.metric}</div>
                                    <div class="highlight-label">${highlight.label}</div>
                                </div>
                            `;
                        });
                        highlightsHtml += '</div>';
                    }

                    html += `
                        <header class="hero animated-section">
                            <h1>${data.hero.title}</h1>
                            <p class="pico-color-secondary">${data.hero.subtitle}</p>
                            ${highlightsHtml}
                            <div class="hero-actions">
                                ${data.hero.callToActions ? data.hero.callToActions.map(action => `
                                    <a href="${action.link}" role="button" class="${action.primary ? 'btn-primary' : 'btn-secondary'}" ${action.link.startsWith('http') ? 'target="_blank" rel="noopener"' : ''}>
                                        ${action.text}
                                    </a>
                                `).join('') : ''}
                                ${data.hero.callToAction ? `<a href="${data.hero.callToAction.link}" role="button" ${data.hero.callToAction.link.startsWith('http') ? 'target="_blank" rel="noopener"' : ''}>${data.hero.callToAction.text}</a>` : ''}
                            </div>
                        </header>
                    `;
                }

                // Render Sections and TOC
                let tocHtml = '';
                data.sections.forEach(section => {
                    let sectionContent = `<section id="${section.id}" class="animated-section">
                                            <h2>${section.title}</h2>
                                            ${section.content.map(renderContentBlock).join('')}`;

                    let tocEntry = `<li><a href="#${section.id}" data-section-id="${section.id}">${section.title}</a>`;

                    // Handle subsections
                    if (section.subsections && section.subsections.length > 0) {
                        tocEntry += '<ul>';
                        section.subsections.forEach(sub => {
                            tocEntry += `<li><a href="#${sub.id}" data-section-id="${sub.id}">${sub.title}</a></li>`;

                            sectionContent += `<article id="${sub.id}" class="subsection">
                                                 <h3>${sub.title}</h3>
                                                 ${sub.content.map(renderContentBlock).join('')}
                                               </article>`;
                        });
                        tocEntry += '</ul>';
                    }

                    tocEntry += '</li>';
                    sectionContent += `</section>`;

                    html += sectionContent;
                    tocHtml += tocEntry;
                });

                config.contentEl.innerHTML = html;
                config.tocEl.innerHTML = tocHtml;
            }

            /**
             * Processes markdown-style links [text](url) in paragraph text
             */
            function processMarkdownLinks(text) {
                return text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, text, url) => {
                    const isExternal = url.startsWith('http://') || url.startsWith('https://');
                    const attributes = isExternal ? ' target="_blank" rel="noopener"' : '';
                    return `<a href="${url}"${attributes}>${text}</a>`;
                });
            }

            /**
             * Renders a single content block based on its type
             */
            function renderContentBlock(block) {
                switch (block.type) {
                    case 'paragraph':
                        return `<p>${processMarkdownLinks(block.value)}</p>`;
                    case 'image':
                        return `<figure>
                                    <img src="${block.value.src}" alt="${block.value.alt}">
                                    <figcaption>${block.value.caption}</figcaption>
                                </figure>`;
                    case 'mermaid':
                        // We wrap in a div for Mermaid to find it
                        return `<div class="mermaid">${block.value}</div>`;
                    case 'kpi-grid':
                        const cards = block.value.map(kpi => `
                            <div class="kpi-card">
                                <div class="value">${kpi.value}</div>
                                <div class="label">${kpi.label}</div>
                            </div>`).join('');
                        return `<div class="kpi-grid">${cards}</div>`;
                    case 'blockquote':
                        return `<blockquote>${block.value.text}${block.value.cite ? `<cite>- ${block.value.cite}</cite>` : ''}</blockquote>`;
                    case 'glossary':
                        const glossaryItems = (currentPresentationData?.glossary || []).map(item =>
                            `<dt>${item.term}</dt><dd>${item.definition}</dd>`
                        ).join('');
                        return `<dl class="glossary-list">${glossaryItems}</dl>`;
                    case 'html':
                        return block.value;
                    default:
                        return '';
                }
            }

            /**
             * Finds and replaces glossary terms in the text with interactive <dfn> tags.
             * This is done safely by manipulating text nodes, not innerHTML.
             */
            function processGlossary(glossary) {
                if (!glossary || glossary.length === 0) return;

                const walker = document.createTreeWalker(config.contentEl, NodeFilter.SHOW_TEXT, null, false);
                let node;
                const nodesToProcess = [];

                // First, find all text nodes that need changes. We don't change the DOM while iterating.
                while (node = walker.nextNode()) {
                    const hasTerm = glossary.some(item => new RegExp(`\\b${item.term}\\b`, 'i').test(node.nodeValue));
                    if (hasTerm && node.parentElement.tagName !== 'DFN' && node.parentElement.closest('.mermaid') === null) {
                       nodesToProcess.push(node);
                    }
                }
                
                // Now, process the collected nodes
                nodesToProcess.forEach(textNode => {
                    let fragment = document.createDocumentFragment();
                    let lastIndex = 0;
                    let text = textNode.nodeValue;

                // Escape special regex characters in terms
                function escapeRegExp(string) {
                    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                }

                // Create a combined regex for all terms to find matches in order
                const termsRegex = new RegExp(`\\b(${glossary.map(g => escapeRegExp(g.term)).join('|')})\\b`, 'gi');
                    
                    text.replace(termsRegex, (match, ...args) => {
                        const offset = args[args.length - 2];
                        const termData = glossary.find(g => g.term.toLowerCase() === match.toLowerCase());
                        
                        // Add text before the match
                        if (offset > lastIndex) {
                            fragment.appendChild(document.createTextNode(text.substring(lastIndex, offset)));
                        }
                        
                        // Add the wrapped term
                        const dfn = document.createElement('dfn');
                        dfn.setAttribute('data-definition', termData.definition);
                        dfn.textContent = match;
                        fragment.appendChild(dfn);

                        lastIndex = offset + match.length;
                    });
                    
                    // Add any remaining text after the last match
                    if (lastIndex < text.length) {
                        fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
                    }
                    
                    textNode.parentNode.replaceChild(fragment, textNode);
                });
            }

            /**
             * Helper function to resolve CSS variables to actual hex values
             */
            function resolveCssVar(varName) {
                return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
            }

            /**
             * Returns current theme colors from CSS variables
             */
            function getCurrentColors() {
                function sanitize(value) {
                    const v = (value || '').trim();
                    if (!v || v === 'undefined' || v === 'null' || v === 'NaN') return '';
                    return v;
                }
                return {
                    primary: sanitize(resolveCssVar('--primary')) || '#2563eb',
                    secondary: sanitize(resolveCssVar('--secondary')) || '#6b7280',
                    background: sanitize(resolveCssVar('--background')) || '#ffffff',
                    surface: sanitize(resolveCssVar('--surface')) || '#f8f9fa',
                    text: sanitize(resolveCssVar('--text')) || '#1a1a1a',
                    textSecondary: sanitize(resolveCssVar('--text-secondary')) || '#6c757d'
                };
            }

            /**
             * Whitelisted merge of deck-level Mermaid config with base settings
             */
            const ALLOWED_TOP = new Set([
                "theme", "fontFamily", "flowchart", "sequence", "gantt", "pie", "themeVariables"
            ]);

            function deepMergeAllowed(base, over) {
                if (!over || typeof over !== 'object') return base;
                const out = structuredClone(base);
                for (const [k, v] of Object.entries(over)) {
                    if (!ALLOWED_TOP.has(k)) continue;
                    if (v && typeof v === 'object' && !Array.isArray(v)) {
                        out[k] = deepMergeAllowed(out[k] || {}, v);
                    } else {
                        out[k] = v;
                    }
                }
                return out;
            }

            /**
             * Injects per-chart defaults when no init directive is present
             */
            function withPerChartInit(diagramText) {
                if (/^\s*%%\{init:/m.test(diagramText)) return diagramText;
                const m = /^\s*(gantt|graph|flowchart|sequenceDiagram|pie)\b/.exec(diagramText);
                let type = m?.[1] || '';
                if (type === 'graph') type = 'flowchart';
                if (type === 'sequenceDiagram') type = 'sequence';
                const defaults = currentPresentationData?.mermaid?.perChartDefaults?.[type];
                return defaults
                    ? `%%{init: ${JSON.stringify({ [type]: defaults })}}%%\n` + diagramText
                    : diagramText;
            }

            /**
             * Fixes Gantt chart axis label overlap by rotating labels
             */
            function tweakGanttAxisLabels(svg) {
                if (!svg.querySelector('.gantt')) return;
                svg.querySelectorAll('.gantt .xAxis .tick text').forEach(t => {
                    t.setAttribute('transform', 'rotate(-30)');
                    t.setAttribute('text-anchor', 'end');
                    t.style.fontSize = '11px';
                });
            }

            /**
             * Returns the centralized Mermaid configuration object
             */
            // Removed getMermaidConfig() - now using buildMermaidConfig() only

            /* ---------- Mermaid single-render manager ---------- */
            const MermaidManager = (() => {
                function setStoredDef(el, def){ el.setAttribute('data-original-definition', btoa(encodeURIComponent(def))); }
                function getStoredDef(el){
                    const b64 = el.getAttribute('data-original-definition');
                    if (b64) try { return decodeURIComponent(atob(b64)); } catch {}
                    return el.textContent || '';
                }

                async function renderStringInto(def, container) {
                    if (!def) return;
                    def = withPerChartInit(def);          // ← inject per-chart defaults
                    mermaid.initialize(buildMermaidConfig());
                    const id = `m-${Date.now()}-${Math.random().toString(36).slice(2)}`;
                    const svg = await mermaid.render(id, def);
                    container.innerHTML = svg;
                    const s = container.querySelector('svg');
                    if (s) {
                        s.removeAttribute('width'); s.removeAttribute('height');
                        s.setAttribute('preserveAspectRatio','xMinYMin meet');
                        s.style.width = '100%'; s.style.height='auto';
                    }
                }

                async function renderOnce(el) {
                    let def = getStoredDef(el).trim();
                    if (!def) return;
                    def = withPerChartInit(def);          // ← inject per-chart defaults
                    const id = `m-${Date.now()}-${Math.random().toString(36).slice(2)}`;
                    const svg = await mermaid.render(id, def);
                    el.innerHTML = svg;
                    const s = el.querySelector('svg');
                    if (s) {
                        s.removeAttribute('width'); s.removeAttribute('height');
                        s.setAttribute('preserveAspectRatio','xMinYMin meet');
                        s.style.width = '100%'; s.style.height='auto';
                    }
                }

                async function cloneInto(sourceEl, targetContainer) {
                    const def = getStoredDef(sourceEl);
                    const wrapper = document.createElement('div');
                    wrapper.className = 'mermaid-modal';
                    await renderStringInto(def, wrapper);
                    targetContainer.appendChild(wrapper);
                }

                async function rerenderAll() {
                    mermaid.initialize(buildMermaidConfig());
                    const els = document.querySelectorAll('.mermaid');
                    for (const el of els) {
                        const def = getStoredDef(el);
                        if (!def) continue;
                        el.textContent = def;      // reset to source
                        await renderOnce(el);      // render fresh under new theme
                    }
                }

                function initAll() {
                    mermaid.initialize(buildMermaidConfig());
                    document.querySelectorAll('.mermaid').forEach(el => {
                        if (!el.getAttribute('data-original-definition')) {
                            setStoredDef(el, el.textContent || '');
                        }
                        renderOnce(el);
                    });
                }

                return { initAll, rerenderAll, cloneInto };
            })();


            /**
             * Custom scroll-spy for TOC highlighting (replaces IntersectionObserver)
             */
            function initScrollSpy() {
                const nav = document.getElementById('toc-nav');
                const links = Array.from(document.querySelectorAll('#toc-nav a[data-section-id]'));
                const sections = links
                    .map(a => document.getElementById(a.dataset.sectionId))
                    .filter(Boolean);

                const state = { items: [], activeId: null };

                const compute = () => {
                    state.items = sections.map(el => {
                        const top = window.scrollY + el.getBoundingClientRect().top;
                        return { id: el.id, top };
                    }).sort((a,b) => a.top - b.top);
                };

                const setActive = (id) => {
                    if (!id || id === state.activeId) return;
                    state.activeId = id;
                    links.forEach(a => {
                        const isActive = a.dataset.sectionId === id;
                        a.classList.toggle('active', isActive);
                        if (isActive) a.setAttribute('aria-current', 'true');
                        else a.removeAttribute('aria-current');
                    });

                    // keep the active link visible inside a scrollbar-less nav
                    const activeLink = links.find(a => a.dataset.sectionId === id);
                    if (activeLink) {
                        const r = activeLink.getBoundingClientRect();
                        const nr = nav.getBoundingClientRect();
                        if (r.top < nr.top || r.bottom > nr.bottom) {
                            activeLink.scrollIntoView({ block: 'nearest', inline: 'nearest', behavior: 'smooth' });
                        }
                    }
                };

                const onScroll = () => {
                    // choose a point slightly below the top of the viewport
                    const anchor = window.scrollY + window.innerHeight * 0.35;
                    let current = state.items[0]?.id;
                    for (let i = 0; i < state.items.length; i++) {
                        if (state.items[i].top <= anchor) current = state.items[i].id; else break;
                    }
                    setActive(current);
                };

                // handle clicks: prevent default jump, smooth scroll, update hash, set active
                nav.addEventListener('click', (e) => {
                    const a = e.target.closest('a[data-section-id]');
                    if (!a) return;
                    e.preventDefault();
                    const id = a.dataset.sectionId;
                    const el = document.getElementById(id);
                    if (!el) return;
                    setActive(id);
                    el.scrollIntoView({ behavior: 'smooth', block: 'start' }); // respects your scroll-margin-top
                    history.pushState(null, '', `#${id}`);
                }, { signal: abortController.signal });

                // recompute on load/resize/content changes
                compute();
                window.addEventListener('resize', throttle(compute, 100), { signal: abortController.signal });
                window.addEventListener('load', compute, { once: true });

                // Recompute when images finish loading (affects offsets)
                document.querySelectorAll('#presentation-content img').forEach(img => {
                    if (!img.complete) {
                        img.addEventListener('load', throttle(compute, 100), { once: true, signal: abortController.signal });
                    }
                });

                // initial sync (direct links)
                if (location.hash) setActive(location.hash.slice(1));
                onScroll();

                window.addEventListener('scroll', throttle(onScroll, 50), { signal: abortController.signal, passive: true });
            }

            /**
             * Sets up scroll listeners for progress bar and active TOC highlighting
             */
            function setupEventListeners(sections) {
                const sectionsEls = document.querySelectorAll('.animated-section');
                const tocLinks = document.querySelectorAll('#toc-nav a');

                // Intersection Observer for animations
                const animationObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            entry.target.classList.add('is-visible');
                            animationObserver.unobserve(entry.target);
                        }
                    });
                }, { threshold: 0.1 });
                sectionsEls.forEach(section => animationObserver.observe(section));

                // Custom scroll-spy for TOC highlighting (replaces IntersectionObserver)
                initScrollSpy();

                // Scroll listener for progress bar (throttled for performance)
                window.addEventListener('scroll', throttle(() => {
                    const scrollTotal = document.documentElement.scrollHeight - window.innerHeight;
                    const scrollPercentage = (window.scrollY / scrollTotal) * 100;
                    config.progressBarEl.style.width = `${scrollPercentage}%`;
                }, 16), { signal: abortController.signal, passive: true });

                // Navigation controls
                setupNavigationControls(sections);

                // Keyboard shortcuts
                setupKeyboardNavigation(sections);


                // Fullscreen toggle
                setupFullscreenToggle();

                // TOC toggle
                setupTocToggle();

                // File upload
                setupFileUpload();


            }



            /**
             * Sets up navigation controls
             */
            function setupNavigationControls(sections) {
                const prevBtn = document.getElementById('prev-section');
                const nextBtn = document.getElementById('next-section');

                if (!prevBtn || !nextBtn) return;

                let currentSectionIndex = 0;
                const sectionElements = document.querySelectorAll('section[id], article[id]');

                function updateNavigationButtons() {
                    const scrollTop = window.pageYOffset;
                    const windowHeight = window.innerHeight;

                    // Find current section based on scroll position
                    for (let i = sectionElements.length - 1; i >= 0; i--) {
                        const section = sectionElements[i];
                        const rect = section.getBoundingClientRect();
                        if (rect.top <= windowHeight * 0.5) {
                            currentSectionIndex = i;
                            break;
                        }
                    }

                    prevBtn.style.opacity = currentSectionIndex > 0 ? '1' : '0.5';
                    nextBtn.style.opacity = currentSectionIndex < sectionElements.length - 1 ? '1' : '0.5';
                }

                function navigateToSection(index) {
                    if (index >= 0 && index < sectionElements.length) {
                        const targetSection = sectionElements[index];
                        targetSection.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                    }
                }

                prevBtn.addEventListener('click', () => {
                    // Linear mode: go to previous section
                    if (currentSectionIndex > 0) {
                        navigateToSection(currentSectionIndex - 1);
                    }
                });

                nextBtn.addEventListener('click', () => {
                    // Linear mode: go to next section
                    if (currentSectionIndex < sectionElements.length - 1) {
                        navigateToSection(currentSectionIndex + 1);
                    }
                });

                window.addEventListener('scroll', throttle(updateNavigationButtons, 100), { signal: abortController.signal, passive: true });
                updateNavigationButtons();
            }

            /**
             * Sets up keyboard navigation
             */
            function setupKeyboardNavigation(sections) {
                const sectionElements = document.querySelectorAll('section[id], article[id]');
                let currentSectionIndex = 0;

                function navigateToSection(index) {
                    if (index >= 0 && index < sectionElements.length) {
                        const targetSection = sectionElements[index];
                        targetSection.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                        currentSectionIndex = index;
                    }
                }

                document.addEventListener('keydown', (e) => {
                    // Only handle keyboard navigation when not typing in inputs
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                    // Linear mode navigation
                    switch (e.key) {
                        case 'ArrowLeft':
                        case 'ArrowUp':
                            e.preventDefault();
                            if (currentSectionIndex > 0) {
                                navigateToSection(currentSectionIndex - 1);
                            }
                            break;
                        case 'ArrowRight':
                        case 'ArrowDown':
                        case ' ':
                            e.preventDefault();
                            if (currentSectionIndex < sectionElements.length - 1) {
                                navigateToSection(currentSectionIndex + 1);
                            }
                            break;
                        case 'Home':
                            e.preventDefault();
                            navigateToSection(0);
                            break;
                        case 'End':
                            e.preventDefault();
                            navigateToSection(sectionElements.length - 1);
                            break;
                    }
                }, { signal: abortController.signal });

                // Update current section index on scroll
                window.addEventListener('scroll', () => {
                    const scrollTop = window.pageYOffset;
                    const windowHeight = window.innerHeight;

                    for (let i = sectionElements.length - 1; i >= 0; i--) {
                        const section = sectionElements[i];
                        const rect = section.getBoundingClientRect();
                        if (rect.top <= windowHeight * 0.5) {
                            currentSectionIndex = i;
                            break;
                        }
                    }
                }, { signal: abortController.signal, passive: true });
            }

            /**
             * Sets up fullscreen toggle functionality
             */
            function setupFullscreenToggle() {
                const fullscreenBtn = document.getElementById('fullscreen-toggle');
                if (!fullscreenBtn) return;

                let isFullscreen = false;

                function toggleFullscreen() {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen().then(() => {
                            isFullscreen = true;
                            updateFullscreenButton();
                            document.body.classList.add('presentation-mode');
                        }).catch(() => {});
                    } else {
                        document.exitFullscreen().then(() => {
                            isFullscreen = false;
                            updateFullscreenButton();
                            document.body.classList.remove('presentation-mode');
                        }).catch(() => {});
                    }
                }

                function updateFullscreenButton() {
                    const icon = fullscreenBtn.querySelector('svg');
                    if (isFullscreen) {
                        icon.innerHTML = '<path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 0 2-2h3M3 16h3a2 2 0 0 0 2 2v3"></path>';
                    } else {
                        icon.innerHTML = '<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>';
                    }
                }

                fullscreenBtn.addEventListener('click', toggleFullscreen);

                // Handle fullscreen changes (e.g., ESC key)
                document.addEventListener('fullscreenchange', () => {
                    isFullscreen = !!document.fullscreenElement;
                    updateFullscreenButton();
                    if (isFullscreen) {
                        document.body.classList.add('presentation-mode');
                    } else {
                        document.body.classList.remove('presentation-mode');
                    }
                });

                // Add F key support for fullscreen
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'f' || e.key === 'F') {
                        if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                            e.preventDefault();
                            toggleFullscreen();
                        }
                    }
                }, { signal: abortController.signal });
            }

            /**
             * Sets up TOC toggle functionality
             */
            function setupTocToggle(){
                const btn = document.getElementById('toc-toggle');
                if (!btn) return;

                const toggle = () => document.body.classList.toggle('toc-hidden');

                btn.addEventListener('click', toggle);

                // Keyboard shortcut: H to show or hide TOC in both normal and fullscreen modes
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'h' || e.key === 'H') {
                        if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                            e.preventDefault();
                            toggle();
                        }
                    }
                }, { signal: abortController.signal });

                // Keep button fully visible in both modes
                btn.style.opacity = '1';
            }

            /**
             * Sets up theme toggle functionality
             */
            function setupThemeToggle() {
                const btn = document.getElementById('theme-toggle');
                if (!btn) return;
                const cycle = () => Theme.setMode(Theme.mode === 'dark' ? 'light' : 'dark', currentPresentationData);
                btn.addEventListener('click', cycle);
            }


            // Removed contrast adjustment functions - unified theming eliminates the need

            /**
             * Sets up file upload functionality
             */
            function setupFileUpload() {
                const uploadBtn = document.getElementById('upload-json');
                const fileInput = document.getElementById('json-file-input');

                if (!uploadBtn || !fileInput) return;

                // Handle upload button click
                uploadBtn.addEventListener('click', () => {
                    fileInput.click();
                });

                // Handle file selection
                fileInput.addEventListener('change', async (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    // Check file type
                    const fileName = file.name.toLowerCase();
                    if (!fileName.endsWith('.json') && !fileName.endsWith('.md')) {
                        alert('Please select a JSON or Markdown file.');
                        return;
                    }

                    try {
                        // Show loading state
                        const loadingIndicator = document.getElementById('loading-indicator');
                        loadingIndicator.style.display = 'block';
                        uploadBtn.style.opacity = '0.5';
                        uploadBtn.disabled = true;

                        // Read file content
                        const fileContent = await readFileAsText(file);
                        let data;

                        if (fileName.endsWith('.md')) {
                            // Parse Markdown
                            data = parseMarkdownToPresentation(fileContent);
                        } else {
                            // Parse JSON
                            data = JSON.parse(fileContent);
                            // Validate basic structure
                            if (!data.title || !data.sections) {
                                throw new Error('Invalid presentation format. Missing required fields.');
                            }
                        }

                        // Reload presentation with new data (navigation processing happens in reloadPresentation)
                        await reloadPresentation(data);

                        

                    } catch (error) {
                        alert(`Error loading presentation file: ${error.message}`);
                    } finally {
                        // Reset loading state
                        const loadingIndicator = document.getElementById('loading-indicator');
                        loadingIndicator.style.display = 'none';
                        uploadBtn.style.opacity = '1';
                        uploadBtn.disabled = false;
                        fileInput.value = ''; // Reset file input
                    }
                });

                // Add keyboard shortcut (Ctrl+U)
                document.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'u') {
                        e.preventDefault();
                        fileInput.click();
                    }
                }, { signal: abortController.signal });
            }




            /**
             * Reads a file as text using FileReader API
             */
            function readFileAsText(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(new Error('Failed to read file'));
                    reader.readAsText(file);
                });
            }

            /**
             * Glossary tooltip: prevent overflow by positioning within viewport
             */
            function setupGlossaryTooltip() {
                const tooltip = document.getElementById('glossary-tooltip');
                if (!tooltip) return;

                function positionTooltip(target) {
                    const rect = target.getBoundingClientRect();
                    const tipRect = tooltip.getBoundingClientRect();
                    const margin = 8;
                    let top = rect.top - tipRect.height - margin;
                    if (top < margin) top = rect.bottom + margin;
                    let left = rect.left + rect.width / 2 - tipRect.width / 2;
                    if (left < margin) left = margin;
                    const maxLeft = window.innerWidth - tipRect.width - margin;
                    if (left > maxLeft) left = maxLeft;
                    tooltip.style.top = `${Math.round(top)}px`;
                    tooltip.style.left = `${Math.round(left)}px`;
                }

                function showTooltip(target) {
                    const def = target.getAttribute('data-definition');
                    if (!def) return;
                    tooltip.textContent = def;
                    tooltip.style.display = 'block';
                    positionTooltip(target);
                    tooltip.setAttribute('aria-hidden', 'false');
                }

                function hideTooltip() {
                    tooltip.style.display = 'none';
                    tooltip.setAttribute('aria-hidden', 'true');
                }

                document.addEventListener('mouseover', (e) => {
                    const d = e.target.closest('dfn');
                    if (d) showTooltip(d); else hideTooltip();
                }, { signal: abortController.signal });

                document.addEventListener('mousemove', (e) => {
                    const d = e.target.closest('dfn');
                    if (d && tooltip.style.display === 'block') positionTooltip(d);
                }, { signal: abortController.signal });

                document.addEventListener('mouseout', (e) => {
                    if (!e.relatedTarget || !e.relatedTarget.closest || !e.relatedTarget.closest('dfn')) hideTooltip();
                }, { signal: abortController.signal });
            }

            /**
             * Modal functionality for images and Mermaid diagrams
             */
            function setupModalFunctionality() {
                const modal = document.getElementById('modal-overlay');
                const modalBody = document.getElementById('modal-body');
                const modalClose = document.getElementById('modal-close');

                // Close modal when clicking the close button
                modalClose.addEventListener('click', () => {
                    modal.classList.remove('show');
                    modalBody.innerHTML = '';
                });

                // Close modal when clicking outside the content
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.classList.remove('show');
                        modalBody.innerHTML = '';
                    }
                });

                // Close modal with Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && modal.classList.contains('show')) {
                        modal.classList.remove('show');
                        modalBody.innerHTML = '';
                    }
                }, { signal: abortController.signal });
            }

            /**
             * Make images clickable for modal display (using event delegation)
             */
            function makeImagesClickable() {
                // Use event delegation to avoid re-binding handlers on reload
                document.addEventListener('click', (e) => {
                    if (e.target.matches('figure img')) {
                        const modal = document.getElementById('modal-overlay');
                        const modalBody = document.getElementById('modal-body');
                        const figcaption = e.target.closest('figure').querySelector('figcaption');

                        const wrapper = document.createElement('div');
                        const img = document.createElement('img');
                        img.src = e.target.src;
                        img.alt = e.target.alt || '';
                        img.style.maxWidth = '100%';
                        img.style.maxHeight = '80vh';
                        img.style.objectFit = 'contain';
                        wrapper.appendChild(img);

                        if (figcaption && figcaption.textContent.trim().length > 0) {
                            const cap = document.createElement('p');
                            cap.textContent = figcaption.textContent;
                            cap.style.marginTop = '0.75rem';
                            cap.style.color = 'var(--text)';
                            cap.style.opacity = '0.9';
                            cap.style.fontStyle = 'italic';
                            cap.style.textAlign = 'center';
                            wrapper.appendChild(cap);
                        }

                        modalBody.innerHTML = '';
                        modalBody.appendChild(wrapper);

                        modal.classList.add('show');
                    }
                }, { signal: abortController.signal });
            }

            /**
             * Make Mermaid diagrams clickable for modal display (using event delegation)
             */
            function makeMermaidClickable() {
                // Use event delegation to avoid re-binding handlers on reload
                document.addEventListener('click', (e) => {
                    if (e.target.closest('.mermaid')) {
                        const diagram = e.target.closest('.mermaid');
                        const modal = document.getElementById('modal-overlay');
                        const modalBody = document.getElementById('modal-body');
                        modalBody.innerHTML = '';
                        MermaidManager.cloneInto(diagram, modalBody);
                        modal.classList.add('show');
                    }
                }, { signal: abortController.signal });
            }

            /**
             * Setup all interactive elements after content is loaded
             */
            function setupInteractiveElements() {
                setupModalFunctionality();
                makeImagesClickable();
                makeMermaidClickable();
                setupGlossaryTooltip();
            }

            // Start the application
            document.addEventListener('DOMContentLoaded', async () => {
                await Theme.init();                // set CSS vars once
                init();                             // renders landing or uploaded deck
                setupThemeToggle();                 // binary Light↔Dark
                Theme.onChange(() => MermaidManager.rerenderAll()); // recolor charts on theme change
            });
    </script>
    <div id="glossary-tooltip" role="tooltip" aria-hidden="true"></div>
    
</body>
</html>









